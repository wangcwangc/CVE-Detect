package risk;

import graph.IGraph;
import graph.PathGraph;
import soot.JarAna;
import soot.SootCallGraph;
import soot.SootClass;
import soot.transformer.MethodPathCgTf;
import utiil.GlobalVar;
import utiil.MavenUtil;
import utiil.SootUtil;
import vo.ClassVO;
import vo.DependencyJar;
import vo.MethodVO;
import vo.VulnerableMethod;

import java.nio.file.Path;
import java.util.*;

public class DependencyRisk {
    private final DependencyJar dependencyJar;
    private final Set<VulnerableMethod> vulnerableMethodSet;
    private Set<String> allRiskMethods;
    private final String cveId;

    public DependencyRisk(DependencyJar dependencyJar, Set<VulnerableMethod> vulnerableMethodSet, String cveId) {
        this.dependencyJar = dependencyJar;
        this.vulnerableMethodSet = vulnerableMethodSet;
        this.cveId = cveId;
        initAllMethodVO();
    }

    //<org.apache.logging.log4j.core.impl.DefaultLogEventFactory: org.apache.logging.log4j.core.LogEvent createEvent(java.lang.String,
    //org.apache.logging.log4j.Marker,java.lang.String,org.apache.logging.log4j.Level,org.apache.logging.log4j.message.Message,
    //java.util.List,java.lang.Throwable)>
    private void initAllMethodVO() {
        allRiskMethods = new HashSet<>();
        Map<String, ClassVO> classVOMap = dependencyJar.getAllClass();
        for (VulnerableMethod vulnerableMethod : vulnerableMethodSet) {
            String methodName = vulnerableMethod.getMethodName();
            String[] strings = methodName.split("\\.");
            String className = methodName.replace("." + strings[strings.length - 1], "");
            if (classVOMap.containsKey(className)) {
                ClassVO classVO = classVOMap.get(className);
                for (MethodVO methodVO : classVO.getMethods()) {
                    if (methodName.split("\\.")[strings.length - 1].equals(SootUtil.methodSigToName(methodVO.getMthdSig()))) {
                        String[] targetParams = vulnerableMethod.getMethodParams().toArray(new String[]{});
                        String[] sourceParams = SootUtil.methodSigToParams(methodVO.getMthdSig());
                        if (SootUtil.isSameParams(sourceParams, targetParams)) {
                            allRiskMethods.add(methodVO.getMthdSig());
                            break;
                        }
                    }
                }
            }
        }
    }

    public Set<String> getAllRiskMethods() {
        return allRiskMethods;
    }

    public PathGraph getPathGraph() {
        if (allRiskMethods.size() > 0) {
            IGraph iGraph = SootCallGraph.i().getGraph(this, new MethodPathCgTf(allRiskMethods));
            if (iGraph == null) {
                return new PathGraph(new HashMap<>(), new ArrayList<>());
            }
            return (PathGraph) iGraph;
        } else {
            return new PathGraph(new HashMap<>(), new ArrayList<>());
        }
    }


    public List<String> getJarPaths() throws Exception {
        List<String> classPaths = new ArrayList<>();
        if (GlobalVar.useAllJar) {
            classPaths = dependencyJar.getRepalceClassPath();
        } else {
            MavenUtil.i().getLog().info("not add all jar to process");
            try {
                classPaths.addAll(this.dependencyJar.getJarFilePaths(true));
                classPaths.addAll(this.dependencyJar.getOnlyFatherJarCps(true));
            } catch (NullPointerException e) {
                classPaths = new ArrayList<>();
            }
        }
        return classPaths;
    }
}
